#
# Autogenerated by Thrift Compiler (0.9.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:twisted
#

from thrift.Thrift import TType, TMessageType, TException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None

from zope.interface import Interface, implements
from twisted.internet import defer
from thrift.transport import TTwisted

class Iface(Interface):
  def saveWebEntity(webEntity):
    """
    @param 1 webEntity
    @return id of the web entity

    Parameters:
     - webEntity
    """
    pass

  def createCache(pageItems):
    """
    @param 1 pageItems : list of PageItem objects
    @return id of the created cache

    Parameters:
     - pageItems
    """
    pass

  def indexCache(cacheId):
    """
    @param 1 cacheId : id of the cache
    @return number of indexed PageItems

    Parameters:
     - cacheId
    """
    pass

  def getPrecisionExceptionsFromCache(cacheId):
    """
    @param 1 cacheId : id of the cache
    @return list of lru prefixes

    Parameters:
     - cacheId
    """
    pass

  def createWebEntities(cacheId):
    """
    @param 1 cacheId : id of the cache

    Parameters:
     - cacheId
    """
    pass

  def deleteCache(cacheId):
    """
    @param 1 cacheId : id of the cache

    Parameters:
     - cacheId
    """
    pass

  def markPageWithPrecisionException(pageItemId):
    """
    @param 1 pageItemId : id of the pageItem to be

    Parameters:
     - pageItemId
    """
    pass

  def saveWebEntityCreationRule(webEntityCreationRule):
    """
    @param 1 webEntityCreationRule : webentity creation rule to store

    Parameters:
     - webEntityCreationRule
    """
    pass

  def savePageItems(pageItems):
    """

    @param 1 pageItems : list of PageItem objects

    Parameters:
     - pageItems
    """
    pass

  def saveNodeLinks(nodeLinks):
    """

    @param 1 nodeLinks : list of NodeLink objects

    Parameters:
     - nodeLinks
    """
    pass

  def addLRUtoWebEntity(id, pageItem):
    """
     *
     * @param 1 id : the id of the WebEntity to add this LRU to
     * @param 2 lruItem : the lruItem to be marked as WebEntity
    *

    Parameters:
     - id
     - pageItem
    """
    pass


class Client:
  implements(Iface)

  def __init__(self, transport, oprot_factory):
    self._transport = transport
    self._oprot_factory = oprot_factory
    self._seqid = 0
    self._reqs = {}

  def saveWebEntity(self, webEntity):
    """
    @param 1 webEntity
    @return id of the web entity

    Parameters:
     - webEntity
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_saveWebEntity(webEntity)
    return d

  def send_saveWebEntity(self, webEntity):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('saveWebEntity', TMessageType.CALL, self._seqid)
    args = saveWebEntity_args()
    args.webEntity = webEntity
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_saveWebEntity(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = saveWebEntity_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.x is not None:
      return d.errback(result.x)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "saveWebEntity failed: unknown result"))

  def createCache(self, pageItems):
    """
    @param 1 pageItems : list of PageItem objects
    @return id of the created cache

    Parameters:
     - pageItems
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_createCache(pageItems)
    return d

  def send_createCache(self, pageItems):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('createCache', TMessageType.CALL, self._seqid)
    args = createCache_args()
    args.pageItems = pageItems
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_createCache(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = createCache_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.x is not None:
      return d.errback(result.x)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "createCache failed: unknown result"))

  def indexCache(self, cacheId):
    """
    @param 1 cacheId : id of the cache
    @return number of indexed PageItems

    Parameters:
     - cacheId
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_indexCache(cacheId)
    return d

  def send_indexCache(self, cacheId):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('indexCache', TMessageType.CALL, self._seqid)
    args = indexCache_args()
    args.cacheId = cacheId
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_indexCache(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = indexCache_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.me is not None:
      return d.errback(result.me)
    if result.x is not None:
      return d.errback(result.x)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "indexCache failed: unknown result"))

  def getPrecisionExceptionsFromCache(self, cacheId):
    """
    @param 1 cacheId : id of the cache
    @return list of lru prefixes

    Parameters:
     - cacheId
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_getPrecisionExceptionsFromCache(cacheId)
    return d

  def send_getPrecisionExceptionsFromCache(self, cacheId):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('getPrecisionExceptionsFromCache', TMessageType.CALL, self._seqid)
    args = getPrecisionExceptionsFromCache_args()
    args.cacheId = cacheId
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_getPrecisionExceptionsFromCache(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = getPrecisionExceptionsFromCache_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.me is not None:
      return d.errback(result.me)
    if result.x is not None:
      return d.errback(result.x)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "getPrecisionExceptionsFromCache failed: unknown result"))

  def createWebEntities(self, cacheId):
    """
    @param 1 cacheId : id of the cache

    Parameters:
     - cacheId
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_createWebEntities(cacheId)
    return d

  def send_createWebEntities(self, cacheId):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('createWebEntities', TMessageType.CALL, self._seqid)
    args = createWebEntities_args()
    args.cacheId = cacheId
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_createWebEntities(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = createWebEntities_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.me is not None:
      return d.errback(result.me)
    if result.x is not None:
      return d.errback(result.x)
    return d.callback(None)

  def deleteCache(self, cacheId):
    """
    @param 1 cacheId : id of the cache

    Parameters:
     - cacheId
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_deleteCache(cacheId)
    return d

  def send_deleteCache(self, cacheId):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('deleteCache', TMessageType.CALL, self._seqid)
    args = deleteCache_args()
    args.cacheId = cacheId
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_deleteCache(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = deleteCache_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.me is not None:
      return d.errback(result.me)
    if result.x is not None:
      return d.errback(result.x)
    return d.callback(None)

  def markPageWithPrecisionException(self, pageItemId):
    """
    @param 1 pageItemId : id of the pageItem to be

    Parameters:
     - pageItemId
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_markPageWithPrecisionException(pageItemId)
    return d

  def send_markPageWithPrecisionException(self, pageItemId):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('markPageWithPrecisionException', TMessageType.CALL, self._seqid)
    args = markPageWithPrecisionException_args()
    args.pageItemId = pageItemId
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_markPageWithPrecisionException(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = markPageWithPrecisionException_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.me is not None:
      return d.errback(result.me)
    if result.x is not None:
      return d.errback(result.x)
    return d.callback(None)

  def saveWebEntityCreationRule(self, webEntityCreationRule):
    """
    @param 1 webEntityCreationRule : webentity creation rule to store

    Parameters:
     - webEntityCreationRule
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_saveWebEntityCreationRule(webEntityCreationRule)
    return d

  def send_saveWebEntityCreationRule(self, webEntityCreationRule):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('saveWebEntityCreationRule', TMessageType.CALL, self._seqid)
    args = saveWebEntityCreationRule_args()
    args.webEntityCreationRule = webEntityCreationRule
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_saveWebEntityCreationRule(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = saveWebEntityCreationRule_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.me is not None:
      return d.errback(result.me)
    return d.callback(None)

  def savePageItems(self, pageItems):
    """

    @param 1 pageItems : list of PageItem objects

    Parameters:
     - pageItems
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_savePageItems(pageItems)
    return d

  def send_savePageItems(self, pageItems):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('savePageItems', TMessageType.CALL, self._seqid)
    args = savePageItems_args()
    args.pageItems = pageItems
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_savePageItems(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = savePageItems_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.me is not None:
      return d.errback(result.me)
    return d.callback(None)

  def saveNodeLinks(self, nodeLinks):
    """

    @param 1 nodeLinks : list of NodeLink objects

    Parameters:
     - nodeLinks
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_saveNodeLinks(nodeLinks)
    return d

  def send_saveNodeLinks(self, nodeLinks):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('saveNodeLinks', TMessageType.CALL, self._seqid)
    args = saveNodeLinks_args()
    args.nodeLinks = nodeLinks
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_saveNodeLinks(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = saveNodeLinks_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.me is not None:
      return d.errback(result.me)
    return d.callback(None)

  def addLRUtoWebEntity(self, id, pageItem):
    """
     *
     * @param 1 id : the id of the WebEntity to add this LRU to
     * @param 2 lruItem : the lruItem to be marked as WebEntity
    *

    Parameters:
     - id
     - pageItem
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_addLRUtoWebEntity(id, pageItem)
    return d

  def send_addLRUtoWebEntity(self, id, pageItem):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('addLRUtoWebEntity', TMessageType.CALL, self._seqid)
    args = addLRUtoWebEntity_args()
    args.id = id
    args.pageItem = pageItem
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_addLRUtoWebEntity(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = addLRUtoWebEntity_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.me is not None:
      return d.errback(result.me)
    return d.callback(None)


class Processor(TProcessor):
  implements(Iface)

  def __init__(self, handler):
    self._handler = Iface(handler)
    self._processMap = {}
    self._processMap["saveWebEntity"] = Processor.process_saveWebEntity
    self._processMap["createCache"] = Processor.process_createCache
    self._processMap["indexCache"] = Processor.process_indexCache
    self._processMap["getPrecisionExceptionsFromCache"] = Processor.process_getPrecisionExceptionsFromCache
    self._processMap["createWebEntities"] = Processor.process_createWebEntities
    self._processMap["deleteCache"] = Processor.process_deleteCache
    self._processMap["markPageWithPrecisionException"] = Processor.process_markPageWithPrecisionException
    self._processMap["saveWebEntityCreationRule"] = Processor.process_saveWebEntityCreationRule
    self._processMap["savePageItems"] = Processor.process_savePageItems
    self._processMap["saveNodeLinks"] = Processor.process_saveNodeLinks
    self._processMap["addLRUtoWebEntity"] = Processor.process_addLRUtoWebEntity

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return defer.succeed(None)
    else:
      return self._processMap[name](self, seqid, iprot, oprot)

  def process_saveWebEntity(self, seqid, iprot, oprot):
    args = saveWebEntity_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = saveWebEntity_result()
    d = defer.maybeDeferred(self._handler.saveWebEntity, args.webEntity)
    d.addCallback(self.write_results_success_saveWebEntity, result, seqid, oprot)
    d.addErrback(self.write_results_exception_saveWebEntity, result, seqid, oprot)
    return d

  def write_results_success_saveWebEntity(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("saveWebEntity", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_saveWebEntity(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except MemoryStructureException, x:
      result.x = x
    oprot.writeMessageBegin("saveWebEntity", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createCache(self, seqid, iprot, oprot):
    args = createCache_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createCache_result()
    d = defer.maybeDeferred(self._handler.createCache, args.pageItems)
    d.addCallback(self.write_results_success_createCache, result, seqid, oprot)
    d.addErrback(self.write_results_exception_createCache, result, seqid, oprot)
    return d

  def write_results_success_createCache(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("createCache", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_createCache(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except MemoryStructureException, x:
      result.x = x
    oprot.writeMessageBegin("createCache", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_indexCache(self, seqid, iprot, oprot):
    args = indexCache_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = indexCache_result()
    d = defer.maybeDeferred(self._handler.indexCache, args.cacheId)
    d.addCallback(self.write_results_success_indexCache, result, seqid, oprot)
    d.addErrback(self.write_results_exception_indexCache, result, seqid, oprot)
    return d

  def write_results_success_indexCache(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("indexCache", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_indexCache(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except MemoryStructureException, me:
      result.me = me
    except ObjectNotFoundException, x:
      result.x = x
    oprot.writeMessageBegin("indexCache", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPrecisionExceptionsFromCache(self, seqid, iprot, oprot):
    args = getPrecisionExceptionsFromCache_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPrecisionExceptionsFromCache_result()
    d = defer.maybeDeferred(self._handler.getPrecisionExceptionsFromCache, args.cacheId)
    d.addCallback(self.write_results_success_getPrecisionExceptionsFromCache, result, seqid, oprot)
    d.addErrback(self.write_results_exception_getPrecisionExceptionsFromCache, result, seqid, oprot)
    return d

  def write_results_success_getPrecisionExceptionsFromCache(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("getPrecisionExceptionsFromCache", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_getPrecisionExceptionsFromCache(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except MemoryStructureException, me:
      result.me = me
    except ObjectNotFoundException, x:
      result.x = x
    oprot.writeMessageBegin("getPrecisionExceptionsFromCache", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createWebEntities(self, seqid, iprot, oprot):
    args = createWebEntities_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createWebEntities_result()
    d = defer.maybeDeferred(self._handler.createWebEntities, args.cacheId)
    d.addCallback(self.write_results_success_createWebEntities, result, seqid, oprot)
    d.addErrback(self.write_results_exception_createWebEntities, result, seqid, oprot)
    return d

  def write_results_success_createWebEntities(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("createWebEntities", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_createWebEntities(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except MemoryStructureException, me:
      result.me = me
    except ObjectNotFoundException, x:
      result.x = x
    oprot.writeMessageBegin("createWebEntities", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteCache(self, seqid, iprot, oprot):
    args = deleteCache_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteCache_result()
    d = defer.maybeDeferred(self._handler.deleteCache, args.cacheId)
    d.addCallback(self.write_results_success_deleteCache, result, seqid, oprot)
    d.addErrback(self.write_results_exception_deleteCache, result, seqid, oprot)
    return d

  def write_results_success_deleteCache(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("deleteCache", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_deleteCache(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except MemoryStructureException, me:
      result.me = me
    except ObjectNotFoundException, x:
      result.x = x
    oprot.writeMessageBegin("deleteCache", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_markPageWithPrecisionException(self, seqid, iprot, oprot):
    args = markPageWithPrecisionException_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = markPageWithPrecisionException_result()
    d = defer.maybeDeferred(self._handler.markPageWithPrecisionException, args.pageItemId)
    d.addCallback(self.write_results_success_markPageWithPrecisionException, result, seqid, oprot)
    d.addErrback(self.write_results_exception_markPageWithPrecisionException, result, seqid, oprot)
    return d

  def write_results_success_markPageWithPrecisionException(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("markPageWithPrecisionException", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_markPageWithPrecisionException(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except MemoryStructureException, me:
      result.me = me
    except ObjectNotFoundException, x:
      result.x = x
    oprot.writeMessageBegin("markPageWithPrecisionException", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_saveWebEntityCreationRule(self, seqid, iprot, oprot):
    args = saveWebEntityCreationRule_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = saveWebEntityCreationRule_result()
    d = defer.maybeDeferred(self._handler.saveWebEntityCreationRule, args.webEntityCreationRule)
    d.addCallback(self.write_results_success_saveWebEntityCreationRule, result, seqid, oprot)
    d.addErrback(self.write_results_exception_saveWebEntityCreationRule, result, seqid, oprot)
    return d

  def write_results_success_saveWebEntityCreationRule(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("saveWebEntityCreationRule", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_saveWebEntityCreationRule(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except MemoryStructureException, me:
      result.me = me
    oprot.writeMessageBegin("saveWebEntityCreationRule", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_savePageItems(self, seqid, iprot, oprot):
    args = savePageItems_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = savePageItems_result()
    d = defer.maybeDeferred(self._handler.savePageItems, args.pageItems)
    d.addCallback(self.write_results_success_savePageItems, result, seqid, oprot)
    d.addErrback(self.write_results_exception_savePageItems, result, seqid, oprot)
    return d

  def write_results_success_savePageItems(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("savePageItems", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_savePageItems(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except MemoryStructureException, me:
      result.me = me
    oprot.writeMessageBegin("savePageItems", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_saveNodeLinks(self, seqid, iprot, oprot):
    args = saveNodeLinks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = saveNodeLinks_result()
    d = defer.maybeDeferred(self._handler.saveNodeLinks, args.nodeLinks)
    d.addCallback(self.write_results_success_saveNodeLinks, result, seqid, oprot)
    d.addErrback(self.write_results_exception_saveNodeLinks, result, seqid, oprot)
    return d

  def write_results_success_saveNodeLinks(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("saveNodeLinks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_saveNodeLinks(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except MemoryStructureException, me:
      result.me = me
    oprot.writeMessageBegin("saveNodeLinks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addLRUtoWebEntity(self, seqid, iprot, oprot):
    args = addLRUtoWebEntity_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addLRUtoWebEntity_result()
    d = defer.maybeDeferred(self._handler.addLRUtoWebEntity, args.id, args.pageItem)
    d.addCallback(self.write_results_success_addLRUtoWebEntity, result, seqid, oprot)
    d.addErrback(self.write_results_exception_addLRUtoWebEntity, result, seqid, oprot)
    return d

  def write_results_success_addLRUtoWebEntity(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("addLRUtoWebEntity", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_addLRUtoWebEntity(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except MemoryStructureException, me:
      result.me = me
    oprot.writeMessageBegin("addLRUtoWebEntity", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class saveWebEntity_args:
  """
  Attributes:
   - webEntity
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'webEntity', (WebEntity, WebEntity.thrift_spec), None, ), # 1
  )

  def __init__(self, webEntity=None,):
    self.webEntity = webEntity

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.webEntity = WebEntity()
          self.webEntity.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('saveWebEntity_args')
    if self.webEntity is not None:
      oprot.writeFieldBegin('webEntity', TType.STRUCT, 1)
      self.webEntity.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class saveWebEntity_result:
  """
  Attributes:
   - success
   - x
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'x', (MemoryStructureException, MemoryStructureException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, x=None,):
    self.success = success
    self.x = x

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.x = MemoryStructureException()
          self.x.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('saveWebEntity_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.STRUCT, 1)
      self.x.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createCache_args:
  """
  Attributes:
   - pageItems
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'pageItems', (TType.STRUCT,(PageItem, PageItem.thrift_spec)), None, ), # 1
  )

  def __init__(self, pageItems=None,):
    self.pageItems = pageItems

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.pageItems = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = PageItem()
            _elem28.read(iprot)
            self.pageItems.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createCache_args')
    if self.pageItems is not None:
      oprot.writeFieldBegin('pageItems', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.pageItems))
      for iter29 in self.pageItems:
        iter29.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createCache_result:
  """
  Attributes:
   - success
   - x
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'x', (MemoryStructureException, MemoryStructureException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, x=None,):
    self.success = success
    self.x = x

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.x = MemoryStructureException()
          self.x.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createCache_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.STRUCT, 1)
      self.x.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class indexCache_args:
  """
  Attributes:
   - cacheId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'cacheId', None, None, ), # 1
  )

  def __init__(self, cacheId=None,):
    self.cacheId = cacheId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.cacheId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('indexCache_args')
    if self.cacheId is not None:
      oprot.writeFieldBegin('cacheId', TType.STRING, 1)
      oprot.writeString(self.cacheId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class indexCache_result:
  """
  Attributes:
   - success
   - me
   - x
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'me', (MemoryStructureException, MemoryStructureException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'x', (ObjectNotFoundException, ObjectNotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, me=None, x=None,):
    self.success = success
    self.me = me
    self.x = x

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.me = MemoryStructureException()
          self.me.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.x = ObjectNotFoundException()
          self.x.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('indexCache_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.me is not None:
      oprot.writeFieldBegin('me', TType.STRUCT, 1)
      self.me.write(oprot)
      oprot.writeFieldEnd()
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.STRUCT, 2)
      self.x.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPrecisionExceptionsFromCache_args:
  """
  Attributes:
   - cacheId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'cacheId', None, None, ), # 1
  )

  def __init__(self, cacheId=None,):
    self.cacheId = cacheId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.cacheId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPrecisionExceptionsFromCache_args')
    if self.cacheId is not None:
      oprot.writeFieldBegin('cacheId', TType.STRING, 1)
      oprot.writeString(self.cacheId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPrecisionExceptionsFromCache_result:
  """
  Attributes:
   - success
   - me
   - x
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'me', (MemoryStructureException, MemoryStructureException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'x', (ObjectNotFoundException, ObjectNotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, me=None, x=None,):
    self.success = success
    self.me = me
    self.x = x

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = iprot.readString();
            self.success.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.me = MemoryStructureException()
          self.me.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.x = ObjectNotFoundException()
          self.x.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPrecisionExceptionsFromCache_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter36 in self.success:
        oprot.writeString(iter36)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.me is not None:
      oprot.writeFieldBegin('me', TType.STRUCT, 1)
      self.me.write(oprot)
      oprot.writeFieldEnd()
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.STRUCT, 2)
      self.x.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createWebEntities_args:
  """
  Attributes:
   - cacheId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'cacheId', None, None, ), # 1
  )

  def __init__(self, cacheId=None,):
    self.cacheId = cacheId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.cacheId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createWebEntities_args')
    if self.cacheId is not None:
      oprot.writeFieldBegin('cacheId', TType.STRING, 1)
      oprot.writeString(self.cacheId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createWebEntities_result:
  """
  Attributes:
   - me
   - x
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'me', (MemoryStructureException, MemoryStructureException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'x', (ObjectNotFoundException, ObjectNotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, me=None, x=None,):
    self.me = me
    self.x = x

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.me = MemoryStructureException()
          self.me.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.x = ObjectNotFoundException()
          self.x.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createWebEntities_result')
    if self.me is not None:
      oprot.writeFieldBegin('me', TType.STRUCT, 1)
      self.me.write(oprot)
      oprot.writeFieldEnd()
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.STRUCT, 2)
      self.x.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteCache_args:
  """
  Attributes:
   - cacheId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'cacheId', None, None, ), # 1
  )

  def __init__(self, cacheId=None,):
    self.cacheId = cacheId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.cacheId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteCache_args')
    if self.cacheId is not None:
      oprot.writeFieldBegin('cacheId', TType.STRING, 1)
      oprot.writeString(self.cacheId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteCache_result:
  """
  Attributes:
   - me
   - x
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'me', (MemoryStructureException, MemoryStructureException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'x', (ObjectNotFoundException, ObjectNotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, me=None, x=None,):
    self.me = me
    self.x = x

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.me = MemoryStructureException()
          self.me.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.x = ObjectNotFoundException()
          self.x.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteCache_result')
    if self.me is not None:
      oprot.writeFieldBegin('me', TType.STRUCT, 1)
      self.me.write(oprot)
      oprot.writeFieldEnd()
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.STRUCT, 2)
      self.x.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markPageWithPrecisionException_args:
  """
  Attributes:
   - pageItemId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pageItemId', None, None, ), # 1
  )

  def __init__(self, pageItemId=None,):
    self.pageItemId = pageItemId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pageItemId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markPageWithPrecisionException_args')
    if self.pageItemId is not None:
      oprot.writeFieldBegin('pageItemId', TType.STRING, 1)
      oprot.writeString(self.pageItemId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markPageWithPrecisionException_result:
  """
  Attributes:
   - me
   - x
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'me', (MemoryStructureException, MemoryStructureException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'x', (ObjectNotFoundException, ObjectNotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, me=None, x=None,):
    self.me = me
    self.x = x

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.me = MemoryStructureException()
          self.me.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.x = ObjectNotFoundException()
          self.x.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markPageWithPrecisionException_result')
    if self.me is not None:
      oprot.writeFieldBegin('me', TType.STRUCT, 1)
      self.me.write(oprot)
      oprot.writeFieldEnd()
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.STRUCT, 2)
      self.x.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class saveWebEntityCreationRule_args:
  """
  Attributes:
   - webEntityCreationRule
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'webEntityCreationRule', (WebEntityCreationRule, WebEntityCreationRule.thrift_spec), None, ), # 1
  )

  def __init__(self, webEntityCreationRule=None,):
    self.webEntityCreationRule = webEntityCreationRule

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.webEntityCreationRule = WebEntityCreationRule()
          self.webEntityCreationRule.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('saveWebEntityCreationRule_args')
    if self.webEntityCreationRule is not None:
      oprot.writeFieldBegin('webEntityCreationRule', TType.STRUCT, 1)
      self.webEntityCreationRule.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class saveWebEntityCreationRule_result:
  """
  Attributes:
   - me
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'me', (MemoryStructureException, MemoryStructureException.thrift_spec), None, ), # 1
  )

  def __init__(self, me=None,):
    self.me = me

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.me = MemoryStructureException()
          self.me.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('saveWebEntityCreationRule_result')
    if self.me is not None:
      oprot.writeFieldBegin('me', TType.STRUCT, 1)
      self.me.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class savePageItems_args:
  """
  Attributes:
   - pageItems
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'pageItems', (TType.STRUCT,(PageItem, PageItem.thrift_spec)), None, ), # 1
  )

  def __init__(self, pageItems=None,):
    self.pageItems = pageItems

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.pageItems = []
          (_etype40, _size37) = iprot.readListBegin()
          for _i41 in xrange(_size37):
            _elem42 = PageItem()
            _elem42.read(iprot)
            self.pageItems.append(_elem42)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('savePageItems_args')
    if self.pageItems is not None:
      oprot.writeFieldBegin('pageItems', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.pageItems))
      for iter43 in self.pageItems:
        iter43.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class savePageItems_result:
  """
  Attributes:
   - me
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'me', (MemoryStructureException, MemoryStructureException.thrift_spec), None, ), # 1
  )

  def __init__(self, me=None,):
    self.me = me

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.me = MemoryStructureException()
          self.me.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('savePageItems_result')
    if self.me is not None:
      oprot.writeFieldBegin('me', TType.STRUCT, 1)
      self.me.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class saveNodeLinks_args:
  """
  Attributes:
   - nodeLinks
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'nodeLinks', (TType.STRUCT,(NodeLink, NodeLink.thrift_spec)), None, ), # 1
  )

  def __init__(self, nodeLinks=None,):
    self.nodeLinks = nodeLinks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.nodeLinks = []
          (_etype47, _size44) = iprot.readListBegin()
          for _i48 in xrange(_size44):
            _elem49 = NodeLink()
            _elem49.read(iprot)
            self.nodeLinks.append(_elem49)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('saveNodeLinks_args')
    if self.nodeLinks is not None:
      oprot.writeFieldBegin('nodeLinks', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.nodeLinks))
      for iter50 in self.nodeLinks:
        iter50.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class saveNodeLinks_result:
  """
  Attributes:
   - me
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'me', (MemoryStructureException, MemoryStructureException.thrift_spec), None, ), # 1
  )

  def __init__(self, me=None,):
    self.me = me

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.me = MemoryStructureException()
          self.me.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('saveNodeLinks_result')
    if self.me is not None:
      oprot.writeFieldBegin('me', TType.STRUCT, 1)
      self.me.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addLRUtoWebEntity_args:
  """
  Attributes:
   - id
   - pageItem
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRUCT, 'pageItem', (PageItem, PageItem.thrift_spec), None, ), # 2
  )

  def __init__(self, id=None, pageItem=None,):
    self.id = id
    self.pageItem = pageItem

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.pageItem = PageItem()
          self.pageItem.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addLRUtoWebEntity_args')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.pageItem is not None:
      oprot.writeFieldBegin('pageItem', TType.STRUCT, 2)
      self.pageItem.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addLRUtoWebEntity_result:
  """
  Attributes:
   - me
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'me', (MemoryStructureException, MemoryStructureException.thrift_spec), None, ), # 1
  )

  def __init__(self, me=None,):
    self.me = me

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.me = MemoryStructureException()
          self.me.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addLRUtoWebEntity_result')
    if self.me is not None:
      oprot.writeFieldBegin('me', TType.STRUCT, 1)
      self.me.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
